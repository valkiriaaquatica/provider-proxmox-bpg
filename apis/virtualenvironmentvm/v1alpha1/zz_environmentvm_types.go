// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AgentInitParameters struct {

	// Whether to enable the QEMU agent
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// The maximum amount of time to wait for data from the QEMU agent to become available
	Timeout *string `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// Whether to enable the FSTRIM feature in the QEMU agent
	Trim *bool `json:"trim,omitempty" tf:"trim,omitempty"`

	// The QEMU agent interface type
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type AgentObservation struct {

	// Whether to enable the QEMU agent
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// The maximum amount of time to wait for data from the QEMU agent to become available
	Timeout *string `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// Whether to enable the FSTRIM feature in the QEMU agent
	Trim *bool `json:"trim,omitempty" tf:"trim,omitempty"`

	// The QEMU agent interface type
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type AgentParameters struct {

	// Whether to enable the QEMU agent
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// The maximum amount of time to wait for data from the QEMU agent to become available
	// +kubebuilder:validation:Optional
	Timeout *string `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// Whether to enable the FSTRIM feature in the QEMU agent
	// +kubebuilder:validation:Optional
	Trim *bool `json:"trim,omitempty" tf:"trim,omitempty"`

	// The QEMU agent interface type
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type AmdSevInitParameters struct {

	// Sets policy bit to allow Simultaneous Multi Threading (SMT) (Ignored unless for SEV-SNP)
	AllowSmt *bool `json:"allowSmt,omitempty" tf:"allow_smt,omitempty"`

	// Add kernel hashes to guest firmware for measured linux kernel launch
	KernelHashes *bool `json:"kernelHashes,omitempty" tf:"kernel_hashes,omitempty"`

	// Sets policy bit to disallow debugging of guest
	NoDebug *bool `json:"noDebug,omitempty" tf:"no_debug,omitempty"`

	// Sets policy bit to disallow key sharing with other guests (Ignored for SEV-SNP)
	NoKeySharing *bool `json:"noKeySharing,omitempty" tf:"no_key_sharing,omitempty"`

	// Enable standard SEV with type=std or enable experimental SEV-ES with the es optionor enable experimental SEV-SNP with the snp option.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type AmdSevObservation struct {

	// Sets policy bit to allow Simultaneous Multi Threading (SMT) (Ignored unless for SEV-SNP)
	AllowSmt *bool `json:"allowSmt,omitempty" tf:"allow_smt,omitempty"`

	// Add kernel hashes to guest firmware for measured linux kernel launch
	KernelHashes *bool `json:"kernelHashes,omitempty" tf:"kernel_hashes,omitempty"`

	// Sets policy bit to disallow debugging of guest
	NoDebug *bool `json:"noDebug,omitempty" tf:"no_debug,omitempty"`

	// Sets policy bit to disallow key sharing with other guests (Ignored for SEV-SNP)
	NoKeySharing *bool `json:"noKeySharing,omitempty" tf:"no_key_sharing,omitempty"`

	// Enable standard SEV with type=std or enable experimental SEV-ES with the es optionor enable experimental SEV-SNP with the snp option.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type AmdSevParameters struct {

	// Sets policy bit to allow Simultaneous Multi Threading (SMT) (Ignored unless for SEV-SNP)
	// +kubebuilder:validation:Optional
	AllowSmt *bool `json:"allowSmt,omitempty" tf:"allow_smt,omitempty"`

	// Add kernel hashes to guest firmware for measured linux kernel launch
	// +kubebuilder:validation:Optional
	KernelHashes *bool `json:"kernelHashes,omitempty" tf:"kernel_hashes,omitempty"`

	// Sets policy bit to disallow debugging of guest
	// +kubebuilder:validation:Optional
	NoDebug *bool `json:"noDebug,omitempty" tf:"no_debug,omitempty"`

	// Sets policy bit to disallow key sharing with other guests (Ignored for SEV-SNP)
	// +kubebuilder:validation:Optional
	NoKeySharing *bool `json:"noKeySharing,omitempty" tf:"no_key_sharing,omitempty"`

	// Enable standard SEV with type=std or enable experimental SEV-ES with the es optionor enable experimental SEV-SNP with the snp option.
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type AudioDeviceInitParameters struct {

	// The device
	Device *string `json:"device,omitempty" tf:"device,omitempty"`

	// The driver
	Driver *string `json:"driver,omitempty" tf:"driver,omitempty"`

	// Whether to enable the audio device
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type AudioDeviceObservation struct {

	// The device
	Device *string `json:"device,omitempty" tf:"device,omitempty"`

	// The driver
	Driver *string `json:"driver,omitempty" tf:"driver,omitempty"`

	// Whether to enable the audio device
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type AudioDeviceParameters struct {

	// The device
	// +kubebuilder:validation:Optional
	Device *string `json:"device,omitempty" tf:"device,omitempty"`

	// The driver
	// +kubebuilder:validation:Optional
	Driver *string `json:"driver,omitempty" tf:"driver,omitempty"`

	// Whether to enable the audio device
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type CPUInitParameters struct {

	// The CPU affinity
	Affinity *string `json:"affinity,omitempty" tf:"affinity,omitempty"`

	// The CPU architecture
	Architecture *string `json:"architecture,omitempty" tf:"architecture,omitempty"`

	// The number of CPU cores
	Cores *float64 `json:"cores,omitempty" tf:"cores,omitempty"`

	// The CPU flags
	Flags []*string `json:"flags,omitempty" tf:"flags,omitempty"`

	// The number of hotplugged vCPUs
	Hotplugged *float64 `json:"hotplugged,omitempty" tf:"hotplugged,omitempty"`

	// Limit of CPU usage
	Limit *float64 `json:"limit,omitempty" tf:"limit,omitempty"`

	// Enable/disable NUMA.
	Numa *bool `json:"numa,omitempty" tf:"numa,omitempty"`

	// The number of CPU sockets
	Sockets *float64 `json:"sockets,omitempty" tf:"sockets,omitempty"`

	// The emulated CPU type
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// The CPU units
	Units *float64 `json:"units,omitempty" tf:"units,omitempty"`
}

type CPUObservation struct {

	// The CPU affinity
	Affinity *string `json:"affinity,omitempty" tf:"affinity,omitempty"`

	// The CPU architecture
	Architecture *string `json:"architecture,omitempty" tf:"architecture,omitempty"`

	// The number of CPU cores
	Cores *float64 `json:"cores,omitempty" tf:"cores,omitempty"`

	// The CPU flags
	Flags []*string `json:"flags,omitempty" tf:"flags,omitempty"`

	// The number of hotplugged vCPUs
	Hotplugged *float64 `json:"hotplugged,omitempty" tf:"hotplugged,omitempty"`

	// Limit of CPU usage
	Limit *float64 `json:"limit,omitempty" tf:"limit,omitempty"`

	// Enable/disable NUMA.
	Numa *bool `json:"numa,omitempty" tf:"numa,omitempty"`

	// The number of CPU sockets
	Sockets *float64 `json:"sockets,omitempty" tf:"sockets,omitempty"`

	// The emulated CPU type
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// The CPU units
	Units *float64 `json:"units,omitempty" tf:"units,omitempty"`
}

type CPUParameters struct {

	// The CPU affinity
	// +kubebuilder:validation:Optional
	Affinity *string `json:"affinity,omitempty" tf:"affinity,omitempty"`

	// The CPU architecture
	// +kubebuilder:validation:Optional
	Architecture *string `json:"architecture,omitempty" tf:"architecture,omitempty"`

	// The number of CPU cores
	// +kubebuilder:validation:Optional
	Cores *float64 `json:"cores,omitempty" tf:"cores,omitempty"`

	// The CPU flags
	// +kubebuilder:validation:Optional
	Flags []*string `json:"flags,omitempty" tf:"flags,omitempty"`

	// The number of hotplugged vCPUs
	// +kubebuilder:validation:Optional
	Hotplugged *float64 `json:"hotplugged,omitempty" tf:"hotplugged,omitempty"`

	// Limit of CPU usage
	// +kubebuilder:validation:Optional
	Limit *float64 `json:"limit,omitempty" tf:"limit,omitempty"`

	// Enable/disable NUMA.
	// +kubebuilder:validation:Optional
	Numa *bool `json:"numa,omitempty" tf:"numa,omitempty"`

	// The number of CPU sockets
	// +kubebuilder:validation:Optional
	Sockets *float64 `json:"sockets,omitempty" tf:"sockets,omitempty"`

	// The emulated CPU type
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// The CPU units
	// +kubebuilder:validation:Optional
	Units *float64 `json:"units,omitempty" tf:"units,omitempty"`
}

type CdromInitParameters struct {

	// Whether to enable the CDROM drive
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// The file id
	FileID *string `json:"fileId,omitempty" tf:"file_id,omitempty"`

	// The CDROM interface
	Interface *string `json:"interface,omitempty" tf:"interface,omitempty"`
}

type CdromObservation struct {

	// Whether to enable the CDROM drive
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// The file id
	FileID *string `json:"fileId,omitempty" tf:"file_id,omitempty"`

	// The CDROM interface
	Interface *string `json:"interface,omitempty" tf:"interface,omitempty"`
}

type CdromParameters struct {

	// Whether to enable the CDROM drive
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// The file id
	// +kubebuilder:validation:Optional
	FileID *string `json:"fileId,omitempty" tf:"file_id,omitempty"`

	// The CDROM interface
	// +kubebuilder:validation:Optional
	Interface *string `json:"interface,omitempty" tf:"interface,omitempty"`
}

type CloneInitParameters struct {

	// The ID of the target datastore
	DatastoreID *string `json:"datastoreId,omitempty" tf:"datastore_id,omitempty"`

	// The Clone Type, create a Full Clone (true) or a linked Clone (false)
	Full *bool `json:"full,omitempty" tf:"full,omitempty"`

	// The name of the source node
	NodeName *string `json:"nodeName,omitempty" tf:"node_name,omitempty"`

	// The number of Retries to create a clone
	Retries *float64 `json:"retries,omitempty" tf:"retries,omitempty"`

	// The ID of the source VM
	VMID *float64 `json:"vmId,omitempty" tf:"vm_id,omitempty"`
}

type CloneObservation struct {

	// The ID of the target datastore
	DatastoreID *string `json:"datastoreId,omitempty" tf:"datastore_id,omitempty"`

	// The Clone Type, create a Full Clone (true) or a linked Clone (false)
	Full *bool `json:"full,omitempty" tf:"full,omitempty"`

	// The name of the source node
	NodeName *string `json:"nodeName,omitempty" tf:"node_name,omitempty"`

	// The number of Retries to create a clone
	Retries *float64 `json:"retries,omitempty" tf:"retries,omitempty"`

	// The ID of the source VM
	VMID *float64 `json:"vmId,omitempty" tf:"vm_id,omitempty"`
}

type CloneParameters struct {

	// The ID of the target datastore
	// +kubebuilder:validation:Optional
	DatastoreID *string `json:"datastoreId,omitempty" tf:"datastore_id,omitempty"`

	// The Clone Type, create a Full Clone (true) or a linked Clone (false)
	// +kubebuilder:validation:Optional
	Full *bool `json:"full,omitempty" tf:"full,omitempty"`

	// The name of the source node
	// +kubebuilder:validation:Optional
	NodeName *string `json:"nodeName,omitempty" tf:"node_name,omitempty"`

	// The number of Retries to create a clone
	// +kubebuilder:validation:Optional
	Retries *float64 `json:"retries,omitempty" tf:"retries,omitempty"`

	// The ID of the source VM
	// +kubebuilder:validation:Optional
	VMID *float64 `json:"vmId" tf:"vm_id,omitempty"`
}

type DNSInitParameters struct {

	// The DNS search domain
	Domain *string `json:"domain,omitempty" tf:"domain,omitempty"`

	// The list of DNS servers
	Servers []*string `json:"servers,omitempty" tf:"servers,omitempty"`
}

type DNSObservation struct {

	// The DNS search domain
	Domain *string `json:"domain,omitempty" tf:"domain,omitempty"`

	// The list of DNS servers
	Servers []*string `json:"servers,omitempty" tf:"servers,omitempty"`
}

type DNSParameters struct {

	// The DNS search domain
	// +kubebuilder:validation:Optional
	Domain *string `json:"domain,omitempty" tf:"domain,omitempty"`

	// The list of DNS servers
	// +kubebuilder:validation:Optional
	Servers []*string `json:"servers,omitempty" tf:"servers,omitempty"`
}

type DiskInitParameters struct {

	// The disk AIO mode
	Aio *string `json:"aio,omitempty" tf:"aio,omitempty"`

	// Whether the drive should be included when making backups
	Backup *bool `json:"backup,omitempty" tf:"backup,omitempty"`

	// The drive’s cache mode
	Cache *string `json:"cache,omitempty" tf:"cache,omitempty"`

	// The datastore id
	DatastoreID *string `json:"datastoreId,omitempty" tf:"datastore_id,omitempty"`

	// Whether to pass discard/trim requests to the underlying storage.
	Discard *string `json:"discard,omitempty" tf:"discard,omitempty"`

	// The file format
	FileFormat *string `json:"fileFormat,omitempty" tf:"file_format,omitempty"`

	// The file id for a disk image
	FileID *string `json:"fileId,omitempty" tf:"file_id,omitempty"`

	// The datastore name
	Interface *string `json:"interface,omitempty" tf:"interface,omitempty"`

	// Whether to use iothreads for this disk drive
	Iothread *bool `json:"iothread,omitempty" tf:"iothread,omitempty"`

	// The in-datastore path to disk image
	PathInDatastore *string `json:"pathInDatastore,omitempty" tf:"path_in_datastore,omitempty"`

	// Whether the drive should be considered for replication jobs
	Replicate *bool `json:"replicate,omitempty" tf:"replicate,omitempty"`

	// The drive’s reported serial number
	Serial *string `json:"serial,omitempty" tf:"serial,omitempty"`

	// The disk size in gigabytes
	Size *float64 `json:"size,omitempty" tf:"size,omitempty"`

	// The speed limits
	Speed []SpeedInitParameters `json:"speed,omitempty" tf:"speed,omitempty"`

	// Whether to use ssd for this disk drive
	Ssd *bool `json:"ssd,omitempty" tf:"ssd,omitempty"`
}

type DiskObservation struct {

	// The disk AIO mode
	Aio *string `json:"aio,omitempty" tf:"aio,omitempty"`

	// Whether the drive should be included when making backups
	Backup *bool `json:"backup,omitempty" tf:"backup,omitempty"`

	// The drive’s cache mode
	Cache *string `json:"cache,omitempty" tf:"cache,omitempty"`

	// The datastore id
	DatastoreID *string `json:"datastoreId,omitempty" tf:"datastore_id,omitempty"`

	// Whether to pass discard/trim requests to the underlying storage.
	Discard *string `json:"discard,omitempty" tf:"discard,omitempty"`

	// The file format
	FileFormat *string `json:"fileFormat,omitempty" tf:"file_format,omitempty"`

	// The file id for a disk image
	FileID *string `json:"fileId,omitempty" tf:"file_id,omitempty"`

	// The datastore name
	Interface *string `json:"interface,omitempty" tf:"interface,omitempty"`

	// Whether to use iothreads for this disk drive
	Iothread *bool `json:"iothread,omitempty" tf:"iothread,omitempty"`

	// The in-datastore path to disk image
	PathInDatastore *string `json:"pathInDatastore,omitempty" tf:"path_in_datastore,omitempty"`

	// Whether the drive should be considered for replication jobs
	Replicate *bool `json:"replicate,omitempty" tf:"replicate,omitempty"`

	// The drive’s reported serial number
	Serial *string `json:"serial,omitempty" tf:"serial,omitempty"`

	// The disk size in gigabytes
	Size *float64 `json:"size,omitempty" tf:"size,omitempty"`

	// The speed limits
	Speed []SpeedObservation `json:"speed,omitempty" tf:"speed,omitempty"`

	// Whether to use ssd for this disk drive
	Ssd *bool `json:"ssd,omitempty" tf:"ssd,omitempty"`
}

type DiskParameters struct {

	// The disk AIO mode
	// +kubebuilder:validation:Optional
	Aio *string `json:"aio,omitempty" tf:"aio,omitempty"`

	// Whether the drive should be included when making backups
	// +kubebuilder:validation:Optional
	Backup *bool `json:"backup,omitempty" tf:"backup,omitempty"`

	// The drive’s cache mode
	// +kubebuilder:validation:Optional
	Cache *string `json:"cache,omitempty" tf:"cache,omitempty"`

	// The datastore id
	// +kubebuilder:validation:Optional
	DatastoreID *string `json:"datastoreId,omitempty" tf:"datastore_id,omitempty"`

	// Whether to pass discard/trim requests to the underlying storage.
	// +kubebuilder:validation:Optional
	Discard *string `json:"discard,omitempty" tf:"discard,omitempty"`

	// The file format
	// +kubebuilder:validation:Optional
	FileFormat *string `json:"fileFormat,omitempty" tf:"file_format,omitempty"`

	// The file id for a disk image
	// +kubebuilder:validation:Optional
	FileID *string `json:"fileId,omitempty" tf:"file_id,omitempty"`

	// The datastore name
	// +kubebuilder:validation:Optional
	Interface *string `json:"interface" tf:"interface,omitempty"`

	// Whether to use iothreads for this disk drive
	// +kubebuilder:validation:Optional
	Iothread *bool `json:"iothread,omitempty" tf:"iothread,omitempty"`

	// The in-datastore path to disk image
	// +kubebuilder:validation:Optional
	PathInDatastore *string `json:"pathInDatastore,omitempty" tf:"path_in_datastore,omitempty"`

	// Whether the drive should be considered for replication jobs
	// +kubebuilder:validation:Optional
	Replicate *bool `json:"replicate,omitempty" tf:"replicate,omitempty"`

	// The drive’s reported serial number
	// +kubebuilder:validation:Optional
	Serial *string `json:"serial,omitempty" tf:"serial,omitempty"`

	// The disk size in gigabytes
	// +kubebuilder:validation:Optional
	Size *float64 `json:"size,omitempty" tf:"size,omitempty"`

	// The speed limits
	// +kubebuilder:validation:Optional
	Speed []SpeedParameters `json:"speed,omitempty" tf:"speed,omitempty"`

	// Whether to use ssd for this disk drive
	// +kubebuilder:validation:Optional
	Ssd *bool `json:"ssd,omitempty" tf:"ssd,omitempty"`
}

type EfiDiskInitParameters struct {

	// The datastore id
	DatastoreID *string `json:"datastoreId,omitempty" tf:"datastore_id,omitempty"`

	// The file format
	FileFormat *string `json:"fileFormat,omitempty" tf:"file_format,omitempty"`

	// Use an EFI vars template with distribution-specific and Microsoft Standard keys enrolled, if used with efi type=`4m`.
	PreEnrolledKeys *bool `json:"preEnrolledKeys,omitempty" tf:"pre_enrolled_keys,omitempty"`

	// Size and type of the OVMF EFI disk
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type EfiDiskObservation struct {

	// The datastore id
	DatastoreID *string `json:"datastoreId,omitempty" tf:"datastore_id,omitempty"`

	// The file format
	FileFormat *string `json:"fileFormat,omitempty" tf:"file_format,omitempty"`

	// Use an EFI vars template with distribution-specific and Microsoft Standard keys enrolled, if used with efi type=`4m`.
	PreEnrolledKeys *bool `json:"preEnrolledKeys,omitempty" tf:"pre_enrolled_keys,omitempty"`

	// Size and type of the OVMF EFI disk
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type EfiDiskParameters struct {

	// The datastore id
	// +kubebuilder:validation:Optional
	DatastoreID *string `json:"datastoreId,omitempty" tf:"datastore_id,omitempty"`

	// The file format
	// +kubebuilder:validation:Optional
	FileFormat *string `json:"fileFormat,omitempty" tf:"file_format,omitempty"`

	// Use an EFI vars template with distribution-specific and Microsoft Standard keys enrolled, if used with efi type=`4m`.
	// +kubebuilder:validation:Optional
	PreEnrolledKeys *bool `json:"preEnrolledKeys,omitempty" tf:"pre_enrolled_keys,omitempty"`

	// Size and type of the OVMF EFI disk
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type EnvironmentVMInitParameters struct {

	// Whether to enable ACPI
	Acpi *bool `json:"acpi,omitempty" tf:"acpi,omitempty"`

	// The QEMU agent configuration
	Agent []AgentInitParameters `json:"agent,omitempty" tf:"agent,omitempty"`

	// Secure Encrypted Virtualization (SEV) features by AMD CPUs
	AmdSev []AmdSevInitParameters `json:"amdSev,omitempty" tf:"amd_sev,omitempty"`

	// The audio devices
	AudioDevice []AudioDeviceInitParameters `json:"audioDevice,omitempty" tf:"audio_device,omitempty"`

	// The BIOS implementation
	Bios *string `json:"bios,omitempty" tf:"bios,omitempty"`

	// The guest will attempt to boot from devices in the order they appear here
	BootOrder []*string `json:"bootOrder,omitempty" tf:"boot_order,omitempty"`

	// The CPU allocation
	CPU []CPUInitParameters `json:"cpu,omitempty" tf:"cpu,omitempty"`

	// The CDROM drive
	Cdrom []CdromInitParameters `json:"cdrom,omitempty" tf:"cdrom,omitempty"`

	// The cloning configuration
	Clone []CloneInitParameters `json:"clone,omitempty" tf:"clone,omitempty"`

	// The description
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The disk devices
	Disk []DiskInitParameters `json:"disk,omitempty" tf:"disk,omitempty"`

	// The efidisk device
	EfiDisk []EfiDiskInitParameters `json:"efiDisk,omitempty" tf:"efi_disk,omitempty"`

	// A hook script
	HookScriptFileID *string `json:"hookScriptFileId,omitempty" tf:"hook_script_file_id,omitempty"`

	// The Host PCI devices mapped to the VM
	Hostpci []HostpciInitParameters `json:"hostpci,omitempty" tf:"hostpci,omitempty"`

	// The cloud-init configuration
	Initialization []InitializationInitParameters `json:"initialization,omitempty" tf:"initialization,omitempty"`

	// The keyboard layout
	KeyboardLayout *string `json:"keyboardLayout,omitempty" tf:"keyboard_layout,omitempty"`

	// The args implementation
	KvmArguments *string `json:"kvmArguments,omitempty" tf:"kvm_arguments,omitempty"`

	// The MAC addresses for the network interfaces
	MacAddresses []*string `json:"macAddresses,omitempty" tf:"mac_addresses,omitempty"`

	// The VM machine type, either default `pc` or `q35`
	Machine *string `json:"machine,omitempty" tf:"machine,omitempty"`

	// The memory allocation
	Memory []MemoryInitParameters `json:"memory,omitempty" tf:"memory,omitempty"`

	// Whether to migrate the VM on node change instead of re-creating it
	Migrate *bool `json:"migrate,omitempty" tf:"migrate,omitempty"`

	// The name
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The network devices
	NetworkDevice []NetworkDeviceInitParameters `json:"networkDevice,omitempty" tf:"network_device,omitempty"`

	// The node name
	NodeName *string `json:"nodeName,omitempty" tf:"node_name,omitempty"`

	// The NUMA topology
	Numa []NumaInitParameters `json:"numa,omitempty" tf:"numa,omitempty"`

	// Start VM on Node boot
	OnBoot *bool `json:"onBoot,omitempty" tf:"on_boot,omitempty"`

	// The operating system configuration
	OperatingSystem []OperatingSystemInitParameters `json:"operatingSystem,omitempty" tf:"operating_system,omitempty"`

	// The ID of the pool to assign the virtual machine to
	PoolID *string `json:"poolId,omitempty" tf:"pool_id,omitempty"`

	// Sets the protection flag of the VM. This will disable the remove VM and remove disk operations
	Protection *bool `json:"protection,omitempty" tf:"protection,omitempty"`

	// Whether to reboot VM after creation
	Reboot *bool `json:"reboot,omitempty" tf:"reboot,omitempty"`

	// Whether to reboot VM after update if needed
	RebootAfterUpdate *bool `json:"rebootAfterUpdate,omitempty" tf:"reboot_after_update,omitempty"`

	// The RNG configuration
	Rng []RngInitParameters `json:"rng,omitempty" tf:"rng,omitempty"`

	// The SCSI hardware type
	ScsiHardware *string `json:"scsiHardware,omitempty" tf:"scsi_hardware,omitempty"`

	// The serial devices
	SerialDevice []SerialDeviceInitParameters `json:"serialDevice,omitempty" tf:"serial_device,omitempty"`

	// Specifies SMBIOS (type1) settings for the VM
	Smbios []SmbiosInitParameters `json:"smbios,omitempty" tf:"smbios,omitempty"`

	// Whether to start the virtual machine
	Started *bool `json:"started,omitempty" tf:"started,omitempty"`

	// Defines startup and shutdown behavior of the VM
	Startup []StartupInitParameters `json:"startup,omitempty" tf:"startup,omitempty"`

	// Whether to stop rather than shutdown on VM destroy
	StopOnDestroy *bool `json:"stopOnDestroy,omitempty" tf:"stop_on_destroy,omitempty"`

	// Whether to enable the USB tablet device
	TabletDevice *bool `json:"tabletDevice,omitempty" tf:"tablet_device,omitempty"`

	// Tags of the virtual machine. This is only meta information.
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// Whether to create a template
	Template *bool `json:"template,omitempty" tf:"template,omitempty"`

	// Clone VM timeout
	TimeoutClone *float64 `json:"timeoutClone,omitempty" tf:"timeout_clone,omitempty"`

	// Create VM timeout
	TimeoutCreate *float64 `json:"timeoutCreate,omitempty" tf:"timeout_create,omitempty"`

	// Migrate VM timeout
	TimeoutMigrate *float64 `json:"timeoutMigrate,omitempty" tf:"timeout_migrate,omitempty"`

	// MoveDisk timeout
	TimeoutMoveDisk *float64 `json:"timeoutMoveDisk,omitempty" tf:"timeout_move_disk,omitempty"`

	// Reboot timeout
	TimeoutReboot *float64 `json:"timeoutReboot,omitempty" tf:"timeout_reboot,omitempty"`

	// Shutdown timeout
	TimeoutShutdownVM *float64 `json:"timeoutShutdownVm,omitempty" tf:"timeout_shutdown_vm,omitempty"`

	// Start VM timeout
	TimeoutStartVM *float64 `json:"timeoutStartVm,omitempty" tf:"timeout_start_vm,omitempty"`

	// Stop VM timeout
	TimeoutStopVM *float64 `json:"timeoutStopVm,omitempty" tf:"timeout_stop_vm,omitempty"`

	// The tpmstate device
	TpmState []TpmStateInitParameters `json:"tpmState,omitempty" tf:"tpm_state,omitempty"`

	// The Host USB devices mapped to the VM
	Usb []UsbInitParameters `json:"usb,omitempty" tf:"usb,omitempty"`

	// The VM identifier
	VMID *float64 `json:"vmId,omitempty" tf:"vm_id,omitempty"`

	// The VGA configuration
	Vga []VgaInitParameters `json:"vga,omitempty" tf:"vga,omitempty"`

	// Virtiofs share configuration
	Virtiofs []VirtiofsInitParameters `json:"virtiofs,omitempty" tf:"virtiofs,omitempty"`

	// The watchdog configuration
	Watchdog []WatchdogInitParameters `json:"watchdog,omitempty" tf:"watchdog,omitempty"`
}

type EnvironmentVMObservation struct {

	// Whether to enable ACPI
	Acpi *bool `json:"acpi,omitempty" tf:"acpi,omitempty"`

	// The QEMU agent configuration
	Agent []AgentObservation `json:"agent,omitempty" tf:"agent,omitempty"`

	// Secure Encrypted Virtualization (SEV) features by AMD CPUs
	AmdSev []AmdSevObservation `json:"amdSev,omitempty" tf:"amd_sev,omitempty"`

	// The audio devices
	AudioDevice []AudioDeviceObservation `json:"audioDevice,omitempty" tf:"audio_device,omitempty"`

	// The BIOS implementation
	Bios *string `json:"bios,omitempty" tf:"bios,omitempty"`

	// The guest will attempt to boot from devices in the order they appear here
	BootOrder []*string `json:"bootOrder,omitempty" tf:"boot_order,omitempty"`

	// The CPU allocation
	CPU []CPUObservation `json:"cpu,omitempty" tf:"cpu,omitempty"`

	// The CDROM drive
	Cdrom []CdromObservation `json:"cdrom,omitempty" tf:"cdrom,omitempty"`

	// The cloning configuration
	Clone []CloneObservation `json:"clone,omitempty" tf:"clone,omitempty"`

	// The description
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The disk devices
	Disk []DiskObservation `json:"disk,omitempty" tf:"disk,omitempty"`

	// The efidisk device
	EfiDisk []EfiDiskObservation `json:"efiDisk,omitempty" tf:"efi_disk,omitempty"`

	// A hook script
	HookScriptFileID *string `json:"hookScriptFileId,omitempty" tf:"hook_script_file_id,omitempty"`

	// The Host PCI devices mapped to the VM
	Hostpci []HostpciObservation `json:"hostpci,omitempty" tf:"hostpci,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The IPv4 addresses published by the QEMU agent
	IPv4Addresses [][]*string `json:"ipv4Addresses,omitempty" tf:"ipv4_addresses,omitempty"`

	// The IPv6 addresses published by the QEMU agent
	IPv6Addresses [][]*string `json:"ipv6Addresses,omitempty" tf:"ipv6_addresses,omitempty"`

	// The cloud-init configuration
	Initialization []InitializationObservation `json:"initialization,omitempty" tf:"initialization,omitempty"`

	// The keyboard layout
	KeyboardLayout *string `json:"keyboardLayout,omitempty" tf:"keyboard_layout,omitempty"`

	// The args implementation
	KvmArguments *string `json:"kvmArguments,omitempty" tf:"kvm_arguments,omitempty"`

	// The MAC addresses for the network interfaces
	MacAddresses []*string `json:"macAddresses,omitempty" tf:"mac_addresses,omitempty"`

	// The VM machine type, either default `pc` or `q35`
	Machine *string `json:"machine,omitempty" tf:"machine,omitempty"`

	// The memory allocation
	Memory []MemoryObservation `json:"memory,omitempty" tf:"memory,omitempty"`

	// Whether to migrate the VM on node change instead of re-creating it
	Migrate *bool `json:"migrate,omitempty" tf:"migrate,omitempty"`

	// The name
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The network devices
	NetworkDevice []NetworkDeviceObservation `json:"networkDevice,omitempty" tf:"network_device,omitempty"`

	// The network interface names published by the QEMU agent
	NetworkInterfaceNames []*string `json:"networkInterfaceNames,omitempty" tf:"network_interface_names,omitempty"`

	// The node name
	NodeName *string `json:"nodeName,omitempty" tf:"node_name,omitempty"`

	// The NUMA topology
	Numa []NumaObservation `json:"numa,omitempty" tf:"numa,omitempty"`

	// Start VM on Node boot
	OnBoot *bool `json:"onBoot,omitempty" tf:"on_boot,omitempty"`

	// The operating system configuration
	OperatingSystem []OperatingSystemObservation `json:"operatingSystem,omitempty" tf:"operating_system,omitempty"`

	// The ID of the pool to assign the virtual machine to
	PoolID *string `json:"poolId,omitempty" tf:"pool_id,omitempty"`

	// Sets the protection flag of the VM. This will disable the remove VM and remove disk operations
	Protection *bool `json:"protection,omitempty" tf:"protection,omitempty"`

	// Whether to reboot VM after creation
	Reboot *bool `json:"reboot,omitempty" tf:"reboot,omitempty"`

	// Whether to reboot VM after update if needed
	RebootAfterUpdate *bool `json:"rebootAfterUpdate,omitempty" tf:"reboot_after_update,omitempty"`

	// The RNG configuration
	Rng []RngObservation `json:"rng,omitempty" tf:"rng,omitempty"`

	// The SCSI hardware type
	ScsiHardware *string `json:"scsiHardware,omitempty" tf:"scsi_hardware,omitempty"`

	// The serial devices
	SerialDevice []SerialDeviceObservation `json:"serialDevice,omitempty" tf:"serial_device,omitempty"`

	// Specifies SMBIOS (type1) settings for the VM
	Smbios []SmbiosObservation `json:"smbios,omitempty" tf:"smbios,omitempty"`

	// Whether to start the virtual machine
	Started *bool `json:"started,omitempty" tf:"started,omitempty"`

	// Defines startup and shutdown behavior of the VM
	Startup []StartupObservation `json:"startup,omitempty" tf:"startup,omitempty"`

	// Whether to stop rather than shutdown on VM destroy
	StopOnDestroy *bool `json:"stopOnDestroy,omitempty" tf:"stop_on_destroy,omitempty"`

	// Whether to enable the USB tablet device
	TabletDevice *bool `json:"tabletDevice,omitempty" tf:"tablet_device,omitempty"`

	// Tags of the virtual machine. This is only meta information.
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// Whether to create a template
	Template *bool `json:"template,omitempty" tf:"template,omitempty"`

	// Clone VM timeout
	TimeoutClone *float64 `json:"timeoutClone,omitempty" tf:"timeout_clone,omitempty"`

	// Create VM timeout
	TimeoutCreate *float64 `json:"timeoutCreate,omitempty" tf:"timeout_create,omitempty"`

	// Migrate VM timeout
	TimeoutMigrate *float64 `json:"timeoutMigrate,omitempty" tf:"timeout_migrate,omitempty"`

	// MoveDisk timeout
	TimeoutMoveDisk *float64 `json:"timeoutMoveDisk,omitempty" tf:"timeout_move_disk,omitempty"`

	// Reboot timeout
	TimeoutReboot *float64 `json:"timeoutReboot,omitempty" tf:"timeout_reboot,omitempty"`

	// Shutdown timeout
	TimeoutShutdownVM *float64 `json:"timeoutShutdownVm,omitempty" tf:"timeout_shutdown_vm,omitempty"`

	// Start VM timeout
	TimeoutStartVM *float64 `json:"timeoutStartVm,omitempty" tf:"timeout_start_vm,omitempty"`

	// Stop VM timeout
	TimeoutStopVM *float64 `json:"timeoutStopVm,omitempty" tf:"timeout_stop_vm,omitempty"`

	// The tpmstate device
	TpmState []TpmStateObservation `json:"tpmState,omitempty" tf:"tpm_state,omitempty"`

	// The Host USB devices mapped to the VM
	Usb []UsbObservation `json:"usb,omitempty" tf:"usb,omitempty"`

	// The VM identifier
	VMID *float64 `json:"vmId,omitempty" tf:"vm_id,omitempty"`

	// The VGA configuration
	Vga []VgaObservation `json:"vga,omitempty" tf:"vga,omitempty"`

	// Virtiofs share configuration
	Virtiofs []VirtiofsObservation `json:"virtiofs,omitempty" tf:"virtiofs,omitempty"`

	// The watchdog configuration
	Watchdog []WatchdogObservation `json:"watchdog,omitempty" tf:"watchdog,omitempty"`
}

type EnvironmentVMParameters struct {

	// Whether to enable ACPI
	// +kubebuilder:validation:Optional
	Acpi *bool `json:"acpi,omitempty" tf:"acpi,omitempty"`

	// The QEMU agent configuration
	// +kubebuilder:validation:Optional
	Agent []AgentParameters `json:"agent,omitempty" tf:"agent,omitempty"`

	// Secure Encrypted Virtualization (SEV) features by AMD CPUs
	// +kubebuilder:validation:Optional
	AmdSev []AmdSevParameters `json:"amdSev,omitempty" tf:"amd_sev,omitempty"`

	// The audio devices
	// +kubebuilder:validation:Optional
	AudioDevice []AudioDeviceParameters `json:"audioDevice,omitempty" tf:"audio_device,omitempty"`

	// The BIOS implementation
	// +kubebuilder:validation:Optional
	Bios *string `json:"bios,omitempty" tf:"bios,omitempty"`

	// The guest will attempt to boot from devices in the order they appear here
	// +kubebuilder:validation:Optional
	BootOrder []*string `json:"bootOrder,omitempty" tf:"boot_order,omitempty"`

	// The CPU allocation
	// +kubebuilder:validation:Optional
	CPU []CPUParameters `json:"cpu,omitempty" tf:"cpu,omitempty"`

	// The CDROM drive
	// +kubebuilder:validation:Optional
	Cdrom []CdromParameters `json:"cdrom,omitempty" tf:"cdrom,omitempty"`

	// The cloning configuration
	// +kubebuilder:validation:Optional
	Clone []CloneParameters `json:"clone,omitempty" tf:"clone,omitempty"`

	// The description
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The disk devices
	// +kubebuilder:validation:Optional
	Disk []DiskParameters `json:"disk,omitempty" tf:"disk,omitempty"`

	// The efidisk device
	// +kubebuilder:validation:Optional
	EfiDisk []EfiDiskParameters `json:"efiDisk,omitempty" tf:"efi_disk,omitempty"`

	// A hook script
	// +kubebuilder:validation:Optional
	HookScriptFileID *string `json:"hookScriptFileId,omitempty" tf:"hook_script_file_id,omitempty"`

	// The Host PCI devices mapped to the VM
	// +kubebuilder:validation:Optional
	Hostpci []HostpciParameters `json:"hostpci,omitempty" tf:"hostpci,omitempty"`

	// The cloud-init configuration
	// +kubebuilder:validation:Optional
	Initialization []InitializationParameters `json:"initialization,omitempty" tf:"initialization,omitempty"`

	// The keyboard layout
	// +kubebuilder:validation:Optional
	KeyboardLayout *string `json:"keyboardLayout,omitempty" tf:"keyboard_layout,omitempty"`

	// The args implementation
	// +kubebuilder:validation:Optional
	KvmArguments *string `json:"kvmArguments,omitempty" tf:"kvm_arguments,omitempty"`

	// The MAC addresses for the network interfaces
	// +kubebuilder:validation:Optional
	MacAddresses []*string `json:"macAddresses,omitempty" tf:"mac_addresses,omitempty"`

	// The VM machine type, either default `pc` or `q35`
	// +kubebuilder:validation:Optional
	Machine *string `json:"machine,omitempty" tf:"machine,omitempty"`

	// The memory allocation
	// +kubebuilder:validation:Optional
	Memory []MemoryParameters `json:"memory,omitempty" tf:"memory,omitempty"`

	// Whether to migrate the VM on node change instead of re-creating it
	// +kubebuilder:validation:Optional
	Migrate *bool `json:"migrate,omitempty" tf:"migrate,omitempty"`

	// The name
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The network devices
	// +kubebuilder:validation:Optional
	NetworkDevice []NetworkDeviceParameters `json:"networkDevice,omitempty" tf:"network_device,omitempty"`

	// The node name
	// +kubebuilder:validation:Optional
	NodeName *string `json:"nodeName,omitempty" tf:"node_name,omitempty"`

	// The NUMA topology
	// +kubebuilder:validation:Optional
	Numa []NumaParameters `json:"numa,omitempty" tf:"numa,omitempty"`

	// Start VM on Node boot
	// +kubebuilder:validation:Optional
	OnBoot *bool `json:"onBoot,omitempty" tf:"on_boot,omitempty"`

	// The operating system configuration
	// +kubebuilder:validation:Optional
	OperatingSystem []OperatingSystemParameters `json:"operatingSystem,omitempty" tf:"operating_system,omitempty"`

	// The ID of the pool to assign the virtual machine to
	// +kubebuilder:validation:Optional
	PoolID *string `json:"poolId,omitempty" tf:"pool_id,omitempty"`

	// Sets the protection flag of the VM. This will disable the remove VM and remove disk operations
	// +kubebuilder:validation:Optional
	Protection *bool `json:"protection,omitempty" tf:"protection,omitempty"`

	// Whether to reboot VM after creation
	// +kubebuilder:validation:Optional
	Reboot *bool `json:"reboot,omitempty" tf:"reboot,omitempty"`

	// Whether to reboot VM after update if needed
	// +kubebuilder:validation:Optional
	RebootAfterUpdate *bool `json:"rebootAfterUpdate,omitempty" tf:"reboot_after_update,omitempty"`

	// The RNG configuration
	// +kubebuilder:validation:Optional
	Rng []RngParameters `json:"rng,omitempty" tf:"rng,omitempty"`

	// The SCSI hardware type
	// +kubebuilder:validation:Optional
	ScsiHardware *string `json:"scsiHardware,omitempty" tf:"scsi_hardware,omitempty"`

	// The serial devices
	// +kubebuilder:validation:Optional
	SerialDevice []SerialDeviceParameters `json:"serialDevice,omitempty" tf:"serial_device,omitempty"`

	// Specifies SMBIOS (type1) settings for the VM
	// +kubebuilder:validation:Optional
	Smbios []SmbiosParameters `json:"smbios,omitempty" tf:"smbios,omitempty"`

	// Whether to start the virtual machine
	// +kubebuilder:validation:Optional
	Started *bool `json:"started,omitempty" tf:"started,omitempty"`

	// Defines startup and shutdown behavior of the VM
	// +kubebuilder:validation:Optional
	Startup []StartupParameters `json:"startup,omitempty" tf:"startup,omitempty"`

	// Whether to stop rather than shutdown on VM destroy
	// +kubebuilder:validation:Optional
	StopOnDestroy *bool `json:"stopOnDestroy,omitempty" tf:"stop_on_destroy,omitempty"`

	// Whether to enable the USB tablet device
	// +kubebuilder:validation:Optional
	TabletDevice *bool `json:"tabletDevice,omitempty" tf:"tablet_device,omitempty"`

	// Tags of the virtual machine. This is only meta information.
	// +kubebuilder:validation:Optional
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// Whether to create a template
	// +kubebuilder:validation:Optional
	Template *bool `json:"template,omitempty" tf:"template,omitempty"`

	// Clone VM timeout
	// +kubebuilder:validation:Optional
	TimeoutClone *float64 `json:"timeoutClone,omitempty" tf:"timeout_clone,omitempty"`

	// Create VM timeout
	// +kubebuilder:validation:Optional
	TimeoutCreate *float64 `json:"timeoutCreate,omitempty" tf:"timeout_create,omitempty"`

	// Migrate VM timeout
	// +kubebuilder:validation:Optional
	TimeoutMigrate *float64 `json:"timeoutMigrate,omitempty" tf:"timeout_migrate,omitempty"`

	// MoveDisk timeout
	// +kubebuilder:validation:Optional
	TimeoutMoveDisk *float64 `json:"timeoutMoveDisk,omitempty" tf:"timeout_move_disk,omitempty"`

	// Reboot timeout
	// +kubebuilder:validation:Optional
	TimeoutReboot *float64 `json:"timeoutReboot,omitempty" tf:"timeout_reboot,omitempty"`

	// Shutdown timeout
	// +kubebuilder:validation:Optional
	TimeoutShutdownVM *float64 `json:"timeoutShutdownVm,omitempty" tf:"timeout_shutdown_vm,omitempty"`

	// Start VM timeout
	// +kubebuilder:validation:Optional
	TimeoutStartVM *float64 `json:"timeoutStartVm,omitempty" tf:"timeout_start_vm,omitempty"`

	// Stop VM timeout
	// +kubebuilder:validation:Optional
	TimeoutStopVM *float64 `json:"timeoutStopVm,omitempty" tf:"timeout_stop_vm,omitempty"`

	// The tpmstate device
	// +kubebuilder:validation:Optional
	TpmState []TpmStateParameters `json:"tpmState,omitempty" tf:"tpm_state,omitempty"`

	// The Host USB devices mapped to the VM
	// +kubebuilder:validation:Optional
	Usb []UsbParameters `json:"usb,omitempty" tf:"usb,omitempty"`

	// The VM identifier
	// +kubebuilder:validation:Optional
	VMID *float64 `json:"vmId,omitempty" tf:"vm_id,omitempty"`

	// The VGA configuration
	// +kubebuilder:validation:Optional
	Vga []VgaParameters `json:"vga,omitempty" tf:"vga,omitempty"`

	// Virtiofs share configuration
	// +kubebuilder:validation:Optional
	Virtiofs []VirtiofsParameters `json:"virtiofs,omitempty" tf:"virtiofs,omitempty"`

	// The watchdog configuration
	// +kubebuilder:validation:Optional
	Watchdog []WatchdogParameters `json:"watchdog,omitempty" tf:"watchdog,omitempty"`
}

type HostpciInitParameters struct {

	// The PCI device name for Proxmox, in form of 'hostpciX' where X is a sequential number from 0 to 3
	Device *string `json:"device,omitempty" tf:"device,omitempty"`

	// The PCI ID of the device, for example 0000:00:1f.0 (or 0000:00:1f.0;0000:00:1f.1 for multiple device functions, or 0000:00:1f for all functions). Use either this or mapping.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The resource mapping name of the device, for example gpu. Use either this or id.
	Mapping *string `json:"mapping,omitempty" tf:"mapping,omitempty"`

	// The the mediated device to use
	Mdev *string `json:"mdev,omitempty" tf:"mdev,omitempty"`

	// Tells Proxmox VE to use a PCIe or PCI port. Some guests/device combination require PCIe rather than PCI. PCIe is only available for q35 machine types.
	Pcie *bool `json:"pcie,omitempty" tf:"pcie,omitempty"`

	// A path to a ROM file for the device to use. This is a relative path under /usr/share/kvm/
	RomFile *string `json:"romFile,omitempty" tf:"rom_file,omitempty"`

	// Makes the firmware ROM visible for the guest. Default is true
	Rombar *bool `json:"rombar,omitempty" tf:"rombar,omitempty"`

	// Marks the PCI(e) device as the primary GPU of the VM. With this enabled, the vga configuration argument will be ignored.
	Xvga *bool `json:"xvga,omitempty" tf:"xvga,omitempty"`
}

type HostpciObservation struct {

	// The PCI device name for Proxmox, in form of 'hostpciX' where X is a sequential number from 0 to 3
	Device *string `json:"device,omitempty" tf:"device,omitempty"`

	// The PCI ID of the device, for example 0000:00:1f.0 (or 0000:00:1f.0;0000:00:1f.1 for multiple device functions, or 0000:00:1f for all functions). Use either this or mapping.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The resource mapping name of the device, for example gpu. Use either this or id.
	Mapping *string `json:"mapping,omitempty" tf:"mapping,omitempty"`

	// The the mediated device to use
	Mdev *string `json:"mdev,omitempty" tf:"mdev,omitempty"`

	// Tells Proxmox VE to use a PCIe or PCI port. Some guests/device combination require PCIe rather than PCI. PCIe is only available for q35 machine types.
	Pcie *bool `json:"pcie,omitempty" tf:"pcie,omitempty"`

	// A path to a ROM file for the device to use. This is a relative path under /usr/share/kvm/
	RomFile *string `json:"romFile,omitempty" tf:"rom_file,omitempty"`

	// Makes the firmware ROM visible for the guest. Default is true
	Rombar *bool `json:"rombar,omitempty" tf:"rombar,omitempty"`

	// Marks the PCI(e) device as the primary GPU of the VM. With this enabled, the vga configuration argument will be ignored.
	Xvga *bool `json:"xvga,omitempty" tf:"xvga,omitempty"`
}

type HostpciParameters struct {

	// The PCI device name for Proxmox, in form of 'hostpciX' where X is a sequential number from 0 to 3
	// +kubebuilder:validation:Optional
	Device *string `json:"device" tf:"device,omitempty"`

	// The PCI ID of the device, for example 0000:00:1f.0 (or 0000:00:1f.0;0000:00:1f.1 for multiple device functions, or 0000:00:1f for all functions). Use either this or mapping.
	// +kubebuilder:validation:Optional
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The resource mapping name of the device, for example gpu. Use either this or id.
	// +kubebuilder:validation:Optional
	Mapping *string `json:"mapping,omitempty" tf:"mapping,omitempty"`

	// The the mediated device to use
	// +kubebuilder:validation:Optional
	Mdev *string `json:"mdev,omitempty" tf:"mdev,omitempty"`

	// Tells Proxmox VE to use a PCIe or PCI port. Some guests/device combination require PCIe rather than PCI. PCIe is only available for q35 machine types.
	// +kubebuilder:validation:Optional
	Pcie *bool `json:"pcie,omitempty" tf:"pcie,omitempty"`

	// A path to a ROM file for the device to use. This is a relative path under /usr/share/kvm/
	// +kubebuilder:validation:Optional
	RomFile *string `json:"romFile,omitempty" tf:"rom_file,omitempty"`

	// Makes the firmware ROM visible for the guest. Default is true
	// +kubebuilder:validation:Optional
	Rombar *bool `json:"rombar,omitempty" tf:"rombar,omitempty"`

	// Marks the PCI(e) device as the primary GPU of the VM. With this enabled, the vga configuration argument will be ignored.
	// +kubebuilder:validation:Optional
	Xvga *bool `json:"xvga,omitempty" tf:"xvga,omitempty"`
}

type IPConfigInitParameters struct {

	// The IPv4 configuration
	IPv4 []IPv4InitParameters `json:"ipv4,omitempty" tf:"ipv4,omitempty"`

	// The IPv6 configuration
	IPv6 []IPv6InitParameters `json:"ipv6,omitempty" tf:"ipv6,omitempty"`
}

type IPConfigObservation struct {

	// The IPv4 configuration
	IPv4 []IPv4Observation `json:"ipv4,omitempty" tf:"ipv4,omitempty"`

	// The IPv6 configuration
	IPv6 []IPv6Observation `json:"ipv6,omitempty" tf:"ipv6,omitempty"`
}

type IPConfigParameters struct {

	// The IPv4 configuration
	// +kubebuilder:validation:Optional
	IPv4 []IPv4Parameters `json:"ipv4,omitempty" tf:"ipv4,omitempty"`

	// The IPv6 configuration
	// +kubebuilder:validation:Optional
	IPv6 []IPv6Parameters `json:"ipv6,omitempty" tf:"ipv6,omitempty"`
}

type IPv4InitParameters struct {

	// The IPv4 address
	Address *string `json:"address,omitempty" tf:"address,omitempty"`

	// The IPv4 gateway
	Gateway *string `json:"gateway,omitempty" tf:"gateway,omitempty"`
}

type IPv4Observation struct {

	// The IPv4 address
	Address *string `json:"address,omitempty" tf:"address,omitempty"`

	// The IPv4 gateway
	Gateway *string `json:"gateway,omitempty" tf:"gateway,omitempty"`
}

type IPv4Parameters struct {

	// The IPv4 address
	// +kubebuilder:validation:Optional
	Address *string `json:"address,omitempty" tf:"address,omitempty"`

	// The IPv4 gateway
	// +kubebuilder:validation:Optional
	Gateway *string `json:"gateway,omitempty" tf:"gateway,omitempty"`
}

type IPv6InitParameters struct {

	// The IPv6 address
	Address *string `json:"address,omitempty" tf:"address,omitempty"`

	// The IPv6 gateway
	Gateway *string `json:"gateway,omitempty" tf:"gateway,omitempty"`
}

type IPv6Observation struct {

	// The IPv6 address
	Address *string `json:"address,omitempty" tf:"address,omitempty"`

	// The IPv6 gateway
	Gateway *string `json:"gateway,omitempty" tf:"gateway,omitempty"`
}

type IPv6Parameters struct {

	// The IPv6 address
	// +kubebuilder:validation:Optional
	Address *string `json:"address,omitempty" tf:"address,omitempty"`

	// The IPv6 gateway
	// +kubebuilder:validation:Optional
	Gateway *string `json:"gateway,omitempty" tf:"gateway,omitempty"`
}

type InitializationInitParameters struct {

	// The DNS configuration
	DNS []DNSInitParameters `json:"dns,omitempty" tf:"dns,omitempty"`

	// The datastore id
	DatastoreID *string `json:"datastoreId,omitempty" tf:"datastore_id,omitempty"`

	// The IP configuration
	IPConfig []IPConfigInitParameters `json:"ipConfig,omitempty" tf:"ip_config,omitempty"`

	// The IDE interface on which the CloudInit drive will be added
	Interface *string `json:"interface,omitempty" tf:"interface,omitempty"`

	// The ID of a file containing meta data config
	MetaDataFileID *string `json:"metaDataFileId,omitempty" tf:"meta_data_file_id,omitempty"`

	// The ID of a file containing network config
	NetworkDataFileID *string `json:"networkDataFileId,omitempty" tf:"network_data_file_id,omitempty"`

	// The cloud-init configuration format
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// The user account configuration
	UserAccount []UserAccountInitParameters `json:"userAccount,omitempty" tf:"user_account,omitempty"`

	// The ID of a file containing custom user data
	UserDataFileID *string `json:"userDataFileId,omitempty" tf:"user_data_file_id,omitempty"`

	// The ID of a file containing vendor data
	VendorDataFileID *string `json:"vendorDataFileId,omitempty" tf:"vendor_data_file_id,omitempty"`
}

type InitializationObservation struct {

	// The DNS configuration
	DNS []DNSObservation `json:"dns,omitempty" tf:"dns,omitempty"`

	// The datastore id
	DatastoreID *string `json:"datastoreId,omitempty" tf:"datastore_id,omitempty"`

	// The IP configuration
	IPConfig []IPConfigObservation `json:"ipConfig,omitempty" tf:"ip_config,omitempty"`

	// The IDE interface on which the CloudInit drive will be added
	Interface *string `json:"interface,omitempty" tf:"interface,omitempty"`

	// The ID of a file containing meta data config
	MetaDataFileID *string `json:"metaDataFileId,omitempty" tf:"meta_data_file_id,omitempty"`

	// The ID of a file containing network config
	NetworkDataFileID *string `json:"networkDataFileId,omitempty" tf:"network_data_file_id,omitempty"`

	// The cloud-init configuration format
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// The user account configuration
	UserAccount []UserAccountObservation `json:"userAccount,omitempty" tf:"user_account,omitempty"`

	// The ID of a file containing custom user data
	UserDataFileID *string `json:"userDataFileId,omitempty" tf:"user_data_file_id,omitempty"`

	// The ID of a file containing vendor data
	VendorDataFileID *string `json:"vendorDataFileId,omitempty" tf:"vendor_data_file_id,omitempty"`
}

type InitializationParameters struct {

	// The DNS configuration
	// +kubebuilder:validation:Optional
	DNS []DNSParameters `json:"dns,omitempty" tf:"dns,omitempty"`

	// The datastore id
	// +kubebuilder:validation:Optional
	DatastoreID *string `json:"datastoreId,omitempty" tf:"datastore_id,omitempty"`

	// The IP configuration
	// +kubebuilder:validation:Optional
	IPConfig []IPConfigParameters `json:"ipConfig,omitempty" tf:"ip_config,omitempty"`

	// The IDE interface on which the CloudInit drive will be added
	// +kubebuilder:validation:Optional
	Interface *string `json:"interface,omitempty" tf:"interface,omitempty"`

	// The ID of a file containing meta data config
	// +kubebuilder:validation:Optional
	MetaDataFileID *string `json:"metaDataFileId,omitempty" tf:"meta_data_file_id,omitempty"`

	// The ID of a file containing network config
	// +kubebuilder:validation:Optional
	NetworkDataFileID *string `json:"networkDataFileId,omitempty" tf:"network_data_file_id,omitempty"`

	// The cloud-init configuration format
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// The user account configuration
	// +kubebuilder:validation:Optional
	UserAccount []UserAccountParameters `json:"userAccount,omitempty" tf:"user_account,omitempty"`

	// The ID of a file containing custom user data
	// +kubebuilder:validation:Optional
	UserDataFileID *string `json:"userDataFileId,omitempty" tf:"user_data_file_id,omitempty"`

	// The ID of a file containing vendor data
	// +kubebuilder:validation:Optional
	VendorDataFileID *string `json:"vendorDataFileId,omitempty" tf:"vendor_data_file_id,omitempty"`
}

type MemoryInitParameters struct {

	// The dedicated memory in megabytes
	Dedicated *float64 `json:"dedicated,omitempty" tf:"dedicated,omitempty"`

	// The floating memory in megabytes (balloon)
	Floating *float64 `json:"floating,omitempty" tf:"floating,omitempty"`

	// Enable/disable hugepages memory
	Hugepages *string `json:"hugepages,omitempty" tf:"hugepages,omitempty"`

	// Hugepages will not be deleted after VM shutdown and can be used for subsequent starts
	KeepHugepages *bool `json:"keepHugepages,omitempty" tf:"keep_hugepages,omitempty"`

	// The shared memory in megabytes
	Shared *float64 `json:"shared,omitempty" tf:"shared,omitempty"`
}

type MemoryObservation struct {

	// The dedicated memory in megabytes
	Dedicated *float64 `json:"dedicated,omitempty" tf:"dedicated,omitempty"`

	// The floating memory in megabytes (balloon)
	Floating *float64 `json:"floating,omitempty" tf:"floating,omitempty"`

	// Enable/disable hugepages memory
	Hugepages *string `json:"hugepages,omitempty" tf:"hugepages,omitempty"`

	// Hugepages will not be deleted after VM shutdown and can be used for subsequent starts
	KeepHugepages *bool `json:"keepHugepages,omitempty" tf:"keep_hugepages,omitempty"`

	// The shared memory in megabytes
	Shared *float64 `json:"shared,omitempty" tf:"shared,omitempty"`
}

type MemoryParameters struct {

	// The dedicated memory in megabytes
	// +kubebuilder:validation:Optional
	Dedicated *float64 `json:"dedicated,omitempty" tf:"dedicated,omitempty"`

	// The floating memory in megabytes (balloon)
	// +kubebuilder:validation:Optional
	Floating *float64 `json:"floating,omitempty" tf:"floating,omitempty"`

	// Enable/disable hugepages memory
	// +kubebuilder:validation:Optional
	Hugepages *string `json:"hugepages,omitempty" tf:"hugepages,omitempty"`

	// Hugepages will not be deleted after VM shutdown and can be used for subsequent starts
	// +kubebuilder:validation:Optional
	KeepHugepages *bool `json:"keepHugepages,omitempty" tf:"keep_hugepages,omitempty"`

	// The shared memory in megabytes
	// +kubebuilder:validation:Optional
	Shared *float64 `json:"shared,omitempty" tf:"shared,omitempty"`
}

type NetworkDeviceInitParameters struct {

	// The bridge
	Bridge *string `json:"bridge,omitempty" tf:"bridge,omitempty"`

	// Whether the network device should be disconnected from the network
	Disconnected *bool `json:"disconnected,omitempty" tf:"disconnected,omitempty"`

	// Whether to enable the network device
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// Whether this interface's firewall rules should be used
	Firewall *bool `json:"firewall,omitempty" tf:"firewall,omitempty"`

	// The MAC address
	MacAddress *string `json:"macAddress,omitempty" tf:"mac_address,omitempty"`

	// The model
	Model *string `json:"model,omitempty" tf:"model,omitempty"`

	// Maximum transmission unit (MTU)
	Mtu *float64 `json:"mtu,omitempty" tf:"mtu,omitempty"`

	// Number of packet queues to be used on the device
	Queues *float64 `json:"queues,omitempty" tf:"queues,omitempty"`

	// The rate limit in megabytes per second
	RateLimit *float64 `json:"rateLimit,omitempty" tf:"rate_limit,omitempty"`

	// List of VLAN trunks for the network interface
	Trunks *string `json:"trunks,omitempty" tf:"trunks,omitempty"`

	// The VLAN identifier
	VlanID *float64 `json:"vlanId,omitempty" tf:"vlan_id,omitempty"`
}

type NetworkDeviceObservation struct {

	// The bridge
	Bridge *string `json:"bridge,omitempty" tf:"bridge,omitempty"`

	// Whether the network device should be disconnected from the network
	Disconnected *bool `json:"disconnected,omitempty" tf:"disconnected,omitempty"`

	// Whether to enable the network device
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// Whether this interface's firewall rules should be used
	Firewall *bool `json:"firewall,omitempty" tf:"firewall,omitempty"`

	// The MAC address
	MacAddress *string `json:"macAddress,omitempty" tf:"mac_address,omitempty"`

	// The model
	Model *string `json:"model,omitempty" tf:"model,omitempty"`

	// Maximum transmission unit (MTU)
	Mtu *float64 `json:"mtu,omitempty" tf:"mtu,omitempty"`

	// Number of packet queues to be used on the device
	Queues *float64 `json:"queues,omitempty" tf:"queues,omitempty"`

	// The rate limit in megabytes per second
	RateLimit *float64 `json:"rateLimit,omitempty" tf:"rate_limit,omitempty"`

	// List of VLAN trunks for the network interface
	Trunks *string `json:"trunks,omitempty" tf:"trunks,omitempty"`

	// The VLAN identifier
	VlanID *float64 `json:"vlanId,omitempty" tf:"vlan_id,omitempty"`
}

type NetworkDeviceParameters struct {

	// The bridge
	// +kubebuilder:validation:Optional
	Bridge *string `json:"bridge,omitempty" tf:"bridge,omitempty"`

	// Whether the network device should be disconnected from the network
	// +kubebuilder:validation:Optional
	Disconnected *bool `json:"disconnected,omitempty" tf:"disconnected,omitempty"`

	// Whether to enable the network device
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// Whether this interface's firewall rules should be used
	// +kubebuilder:validation:Optional
	Firewall *bool `json:"firewall,omitempty" tf:"firewall,omitempty"`

	// The MAC address
	// +kubebuilder:validation:Optional
	MacAddress *string `json:"macAddress,omitempty" tf:"mac_address,omitempty"`

	// The model
	// +kubebuilder:validation:Optional
	Model *string `json:"model,omitempty" tf:"model,omitempty"`

	// Maximum transmission unit (MTU)
	// +kubebuilder:validation:Optional
	Mtu *float64 `json:"mtu,omitempty" tf:"mtu,omitempty"`

	// Number of packet queues to be used on the device
	// +kubebuilder:validation:Optional
	Queues *float64 `json:"queues,omitempty" tf:"queues,omitempty"`

	// The rate limit in megabytes per second
	// +kubebuilder:validation:Optional
	RateLimit *float64 `json:"rateLimit,omitempty" tf:"rate_limit,omitempty"`

	// List of VLAN trunks for the network interface
	// +kubebuilder:validation:Optional
	Trunks *string `json:"trunks,omitempty" tf:"trunks,omitempty"`

	// The VLAN identifier
	// +kubebuilder:validation:Optional
	VlanID *float64 `json:"vlanId,omitempty" tf:"vlan_id,omitempty"`
}

type NumaInitParameters struct {

	// CPUs accessing this NUMA node
	Cpus *string `json:"cpus,omitempty" tf:"cpus,omitempty"`

	// Numa node device ID
	Device *string `json:"device,omitempty" tf:"device,omitempty"`

	// Host NUMA nodes to use
	Hostnodes *string `json:"hostnodes,omitempty" tf:"hostnodes,omitempty"`

	// Amount of memory this NUMA node provides
	Memory *float64 `json:"memory,omitempty" tf:"memory,omitempty"`

	// NUMA policy
	Policy *string `json:"policy,omitempty" tf:"policy,omitempty"`
}

type NumaObservation struct {

	// CPUs accessing this NUMA node
	Cpus *string `json:"cpus,omitempty" tf:"cpus,omitempty"`

	// Numa node device ID
	Device *string `json:"device,omitempty" tf:"device,omitempty"`

	// Host NUMA nodes to use
	Hostnodes *string `json:"hostnodes,omitempty" tf:"hostnodes,omitempty"`

	// Amount of memory this NUMA node provides
	Memory *float64 `json:"memory,omitempty" tf:"memory,omitempty"`

	// NUMA policy
	Policy *string `json:"policy,omitempty" tf:"policy,omitempty"`
}

type NumaParameters struct {

	// CPUs accessing this NUMA node
	// +kubebuilder:validation:Optional
	Cpus *string `json:"cpus" tf:"cpus,omitempty"`

	// Numa node device ID
	// +kubebuilder:validation:Optional
	Device *string `json:"device" tf:"device,omitempty"`

	// Host NUMA nodes to use
	// +kubebuilder:validation:Optional
	Hostnodes *string `json:"hostnodes,omitempty" tf:"hostnodes,omitempty"`

	// Amount of memory this NUMA node provides
	// +kubebuilder:validation:Optional
	Memory *float64 `json:"memory" tf:"memory,omitempty"`

	// NUMA policy
	// +kubebuilder:validation:Optional
	Policy *string `json:"policy,omitempty" tf:"policy,omitempty"`
}

type OperatingSystemInitParameters struct {

	// The type
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type OperatingSystemObservation struct {

	// The type
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type OperatingSystemParameters struct {

	// The type
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type RngInitParameters struct {

	// Maximum bytes of entropy allowed to get injected into the guest every `period` milliseconds. Prefer a lower value when using `/dev/random` as source.
	MaxBytes *float64 `json:"maxBytes,omitempty" tf:"max_bytes,omitempty"`

	// Every `period` milliseconds the entropy-injection quota is reset, allowing the guest to retrieve another `max_bytes` of entropy.
	Period *float64 `json:"period,omitempty" tf:"period,omitempty"`

	// The file on the host to gather entropy from. In most cases, `/dev/urandom` should be preferred over `/dev/random` to avoid entropy-starvation issues on the host.
	Source *string `json:"source,omitempty" tf:"source,omitempty"`
}

type RngObservation struct {

	// Maximum bytes of entropy allowed to get injected into the guest every `period` milliseconds. Prefer a lower value when using `/dev/random` as source.
	MaxBytes *float64 `json:"maxBytes,omitempty" tf:"max_bytes,omitempty"`

	// Every `period` milliseconds the entropy-injection quota is reset, allowing the guest to retrieve another `max_bytes` of entropy.
	Period *float64 `json:"period,omitempty" tf:"period,omitempty"`

	// The file on the host to gather entropy from. In most cases, `/dev/urandom` should be preferred over `/dev/random` to avoid entropy-starvation issues on the host.
	Source *string `json:"source,omitempty" tf:"source,omitempty"`
}

type RngParameters struct {

	// Maximum bytes of entropy allowed to get injected into the guest every `period` milliseconds. Prefer a lower value when using `/dev/random` as source.
	// +kubebuilder:validation:Optional
	MaxBytes *float64 `json:"maxBytes,omitempty" tf:"max_bytes,omitempty"`

	// Every `period` milliseconds the entropy-injection quota is reset, allowing the guest to retrieve another `max_bytes` of entropy.
	// +kubebuilder:validation:Optional
	Period *float64 `json:"period,omitempty" tf:"period,omitempty"`

	// The file on the host to gather entropy from. In most cases, `/dev/urandom` should be preferred over `/dev/random` to avoid entropy-starvation issues on the host.
	// +kubebuilder:validation:Optional
	Source *string `json:"source" tf:"source,omitempty"`
}

type SerialDeviceInitParameters struct {

	// The device
	Device *string `json:"device,omitempty" tf:"device,omitempty"`
}

type SerialDeviceObservation struct {

	// The device
	Device *string `json:"device,omitempty" tf:"device,omitempty"`
}

type SerialDeviceParameters struct {

	// The device
	// +kubebuilder:validation:Optional
	Device *string `json:"device,omitempty" tf:"device,omitempty"`
}

type SmbiosInitParameters struct {

	// Sets SMBIOS family string
	Family *string `json:"family,omitempty" tf:"family,omitempty"`

	// Sets SMBIOS manufacturer
	Manufacturer *string `json:"manufacturer,omitempty" tf:"manufacturer,omitempty"`

	// Sets SMBIOS product ID
	Product *string `json:"product,omitempty" tf:"product,omitempty"`

	// Sets SMBIOS serial number
	Serial *string `json:"serial,omitempty" tf:"serial,omitempty"`

	// Sets SMBIOS SKU
	Sku *string `json:"sku,omitempty" tf:"sku,omitempty"`

	// Sets SMBIOS UUID
	UUID *string `json:"uuid,omitempty" tf:"uuid,omitempty"`

	// Sets SMBIOS version
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type SmbiosObservation struct {

	// Sets SMBIOS family string
	Family *string `json:"family,omitempty" tf:"family,omitempty"`

	// Sets SMBIOS manufacturer
	Manufacturer *string `json:"manufacturer,omitempty" tf:"manufacturer,omitempty"`

	// Sets SMBIOS product ID
	Product *string `json:"product,omitempty" tf:"product,omitempty"`

	// Sets SMBIOS serial number
	Serial *string `json:"serial,omitempty" tf:"serial,omitempty"`

	// Sets SMBIOS SKU
	Sku *string `json:"sku,omitempty" tf:"sku,omitempty"`

	// Sets SMBIOS UUID
	UUID *string `json:"uuid,omitempty" tf:"uuid,omitempty"`

	// Sets SMBIOS version
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type SmbiosParameters struct {

	// Sets SMBIOS family string
	// +kubebuilder:validation:Optional
	Family *string `json:"family,omitempty" tf:"family,omitempty"`

	// Sets SMBIOS manufacturer
	// +kubebuilder:validation:Optional
	Manufacturer *string `json:"manufacturer,omitempty" tf:"manufacturer,omitempty"`

	// Sets SMBIOS product ID
	// +kubebuilder:validation:Optional
	Product *string `json:"product,omitempty" tf:"product,omitempty"`

	// Sets SMBIOS serial number
	// +kubebuilder:validation:Optional
	Serial *string `json:"serial,omitempty" tf:"serial,omitempty"`

	// Sets SMBIOS SKU
	// +kubebuilder:validation:Optional
	Sku *string `json:"sku,omitempty" tf:"sku,omitempty"`

	// Sets SMBIOS UUID
	// +kubebuilder:validation:Optional
	UUID *string `json:"uuid,omitempty" tf:"uuid,omitempty"`

	// Sets SMBIOS version
	// +kubebuilder:validation:Optional
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type SpeedInitParameters struct {

	// The maximum read I/O in operations per second
	IopsRead *float64 `json:"iopsRead,omitempty" tf:"iops_read,omitempty"`

	// The maximum unthrottled read I/O pool in operations per second
	IopsReadBurstable *float64 `json:"iopsReadBurstable,omitempty" tf:"iops_read_burstable,omitempty"`

	// The maximum write I/O in operations per second
	IopsWrite *float64 `json:"iopsWrite,omitempty" tf:"iops_write,omitempty"`

	// The maximum unthrottled write I/O pool in operations per second
	IopsWriteBurstable *float64 `json:"iopsWriteBurstable,omitempty" tf:"iops_write_burstable,omitempty"`

	// The maximum read speed in megabytes per second
	Read *float64 `json:"read,omitempty" tf:"read,omitempty"`

	// The maximum burstable read speed in megabytes per second
	ReadBurstable *float64 `json:"readBurstable,omitempty" tf:"read_burstable,omitempty"`

	// The maximum write speed in megabytes per second
	Write *float64 `json:"write,omitempty" tf:"write,omitempty"`

	// The maximum burstable write speed in megabytes per second
	WriteBurstable *float64 `json:"writeBurstable,omitempty" tf:"write_burstable,omitempty"`
}

type SpeedObservation struct {

	// The maximum read I/O in operations per second
	IopsRead *float64 `json:"iopsRead,omitempty" tf:"iops_read,omitempty"`

	// The maximum unthrottled read I/O pool in operations per second
	IopsReadBurstable *float64 `json:"iopsReadBurstable,omitempty" tf:"iops_read_burstable,omitempty"`

	// The maximum write I/O in operations per second
	IopsWrite *float64 `json:"iopsWrite,omitempty" tf:"iops_write,omitempty"`

	// The maximum unthrottled write I/O pool in operations per second
	IopsWriteBurstable *float64 `json:"iopsWriteBurstable,omitempty" tf:"iops_write_burstable,omitempty"`

	// The maximum read speed in megabytes per second
	Read *float64 `json:"read,omitempty" tf:"read,omitempty"`

	// The maximum burstable read speed in megabytes per second
	ReadBurstable *float64 `json:"readBurstable,omitempty" tf:"read_burstable,omitempty"`

	// The maximum write speed in megabytes per second
	Write *float64 `json:"write,omitempty" tf:"write,omitempty"`

	// The maximum burstable write speed in megabytes per second
	WriteBurstable *float64 `json:"writeBurstable,omitempty" tf:"write_burstable,omitempty"`
}

type SpeedParameters struct {

	// The maximum read I/O in operations per second
	// +kubebuilder:validation:Optional
	IopsRead *float64 `json:"iopsRead,omitempty" tf:"iops_read,omitempty"`

	// The maximum unthrottled read I/O pool in operations per second
	// +kubebuilder:validation:Optional
	IopsReadBurstable *float64 `json:"iopsReadBurstable,omitempty" tf:"iops_read_burstable,omitempty"`

	// The maximum write I/O in operations per second
	// +kubebuilder:validation:Optional
	IopsWrite *float64 `json:"iopsWrite,omitempty" tf:"iops_write,omitempty"`

	// The maximum unthrottled write I/O pool in operations per second
	// +kubebuilder:validation:Optional
	IopsWriteBurstable *float64 `json:"iopsWriteBurstable,omitempty" tf:"iops_write_burstable,omitempty"`

	// The maximum read speed in megabytes per second
	// +kubebuilder:validation:Optional
	Read *float64 `json:"read,omitempty" tf:"read,omitempty"`

	// The maximum burstable read speed in megabytes per second
	// +kubebuilder:validation:Optional
	ReadBurstable *float64 `json:"readBurstable,omitempty" tf:"read_burstable,omitempty"`

	// The maximum write speed in megabytes per second
	// +kubebuilder:validation:Optional
	Write *float64 `json:"write,omitempty" tf:"write,omitempty"`

	// The maximum burstable write speed in megabytes per second
	// +kubebuilder:validation:Optional
	WriteBurstable *float64 `json:"writeBurstable,omitempty" tf:"write_burstable,omitempty"`
}

type StartupInitParameters struct {

	// A non-negative number defining the delay in seconds before the next VM is shut down
	DownDelay *float64 `json:"downDelay,omitempty" tf:"down_delay,omitempty"`

	// A non-negative number defining the general startup order
	Order *float64 `json:"order,omitempty" tf:"order,omitempty"`

	// A non-negative number defining the delay in seconds before the next VM is started
	UpDelay *float64 `json:"upDelay,omitempty" tf:"up_delay,omitempty"`
}

type StartupObservation struct {

	// A non-negative number defining the delay in seconds before the next VM is shut down
	DownDelay *float64 `json:"downDelay,omitempty" tf:"down_delay,omitempty"`

	// A non-negative number defining the general startup order
	Order *float64 `json:"order,omitempty" tf:"order,omitempty"`

	// A non-negative number defining the delay in seconds before the next VM is started
	UpDelay *float64 `json:"upDelay,omitempty" tf:"up_delay,omitempty"`
}

type StartupParameters struct {

	// A non-negative number defining the delay in seconds before the next VM is shut down
	// +kubebuilder:validation:Optional
	DownDelay *float64 `json:"downDelay,omitempty" tf:"down_delay,omitempty"`

	// A non-negative number defining the general startup order
	// +kubebuilder:validation:Optional
	Order *float64 `json:"order,omitempty" tf:"order,omitempty"`

	// A non-negative number defining the delay in seconds before the next VM is started
	// +kubebuilder:validation:Optional
	UpDelay *float64 `json:"upDelay,omitempty" tf:"up_delay,omitempty"`
}

type TpmStateInitParameters struct {

	// Datastore ID
	DatastoreID *string `json:"datastoreId,omitempty" tf:"datastore_id,omitempty"`

	// TPM version
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type TpmStateObservation struct {

	// Datastore ID
	DatastoreID *string `json:"datastoreId,omitempty" tf:"datastore_id,omitempty"`

	// TPM version
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type TpmStateParameters struct {

	// Datastore ID
	// +kubebuilder:validation:Optional
	DatastoreID *string `json:"datastoreId,omitempty" tf:"datastore_id,omitempty"`

	// TPM version
	// +kubebuilder:validation:Optional
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type UsbInitParameters struct {

	// The USB device ID for Proxmox, in form of '<MANUFACTURER>:<ID>'
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// The resource mapping name of the device, for example usbdisk. Use either this or id.
	Mapping *string `json:"mapping,omitempty" tf:"mapping,omitempty"`

	// Makes the USB device a USB3 device for the machine. Default is false
	Usb3 *bool `json:"usb3,omitempty" tf:"usb3,omitempty"`
}

type UsbObservation struct {

	// The USB device ID for Proxmox, in form of '<MANUFACTURER>:<ID>'
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// The resource mapping name of the device, for example usbdisk. Use either this or id.
	Mapping *string `json:"mapping,omitempty" tf:"mapping,omitempty"`

	// Makes the USB device a USB3 device for the machine. Default is false
	Usb3 *bool `json:"usb3,omitempty" tf:"usb3,omitempty"`
}

type UsbParameters struct {

	// The USB device ID for Proxmox, in form of '<MANUFACTURER>:<ID>'
	// +kubebuilder:validation:Optional
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// The resource mapping name of the device, for example usbdisk. Use either this or id.
	// +kubebuilder:validation:Optional
	Mapping *string `json:"mapping,omitempty" tf:"mapping,omitempty"`

	// Makes the USB device a USB3 device for the machine. Default is false
	// +kubebuilder:validation:Optional
	Usb3 *bool `json:"usb3,omitempty" tf:"usb3,omitempty"`
}

type UserAccountInitParameters struct {

	// The SSH keys
	Keys []*string `json:"keys,omitempty" tf:"keys,omitempty"`

	// The SSH password
	PasswordSecretRef *v1.SecretKeySelector `json:"passwordSecretRef,omitempty" tf:"-"`

	// The SSH username
	Username *string `json:"username,omitempty" tf:"username,omitempty"`
}

type UserAccountObservation struct {

	// The SSH keys
	Keys []*string `json:"keys,omitempty" tf:"keys,omitempty"`

	// The SSH username
	Username *string `json:"username,omitempty" tf:"username,omitempty"`
}

type UserAccountParameters struct {

	// The SSH keys
	// +kubebuilder:validation:Optional
	Keys []*string `json:"keys,omitempty" tf:"keys,omitempty"`

	// The SSH password
	// +kubebuilder:validation:Optional
	PasswordSecretRef *v1.SecretKeySelector `json:"passwordSecretRef,omitempty" tf:"-"`

	// The SSH username
	// +kubebuilder:validation:Optional
	Username *string `json:"username,omitempty" tf:"username,omitempty"`
}

type VgaInitParameters struct {

	// Enable clipboard support. Set to `vnc` to enable clipboard support for VNC.
	Clipboard *string `json:"clipboard,omitempty" tf:"clipboard,omitempty"`

	// The VGA memory in megabytes (4-512 MB)
	Memory *float64 `json:"memory,omitempty" tf:"memory,omitempty"`

	// The VGA type
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type VgaObservation struct {

	// Enable clipboard support. Set to `vnc` to enable clipboard support for VNC.
	Clipboard *string `json:"clipboard,omitempty" tf:"clipboard,omitempty"`

	// The VGA memory in megabytes (4-512 MB)
	Memory *float64 `json:"memory,omitempty" tf:"memory,omitempty"`

	// The VGA type
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type VgaParameters struct {

	// Enable clipboard support. Set to `vnc` to enable clipboard support for VNC.
	// +kubebuilder:validation:Optional
	Clipboard *string `json:"clipboard,omitempty" tf:"clipboard,omitempty"`

	// The VGA memory in megabytes (4-512 MB)
	// +kubebuilder:validation:Optional
	Memory *float64 `json:"memory,omitempty" tf:"memory,omitempty"`

	// The VGA type
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type VirtiofsInitParameters struct {

	// The caching mode
	Cache *string `json:"cache,omitempty" tf:"cache,omitempty"`

	// Whether to allow direct io
	DirectIo *bool `json:"directIo,omitempty" tf:"direct_io,omitempty"`

	// Enable POSIX ACLs, implies xattr support
	ExposeACL *bool `json:"exposeAcl,omitempty" tf:"expose_acl,omitempty"`

	// Enable support for extended attributes
	ExposeXattr *bool `json:"exposeXattr,omitempty" tf:"expose_xattr,omitempty"`

	// Directory mapping identifier
	Mapping *string `json:"mapping,omitempty" tf:"mapping,omitempty"`
}

type VirtiofsObservation struct {

	// The caching mode
	Cache *string `json:"cache,omitempty" tf:"cache,omitempty"`

	// Whether to allow direct io
	DirectIo *bool `json:"directIo,omitempty" tf:"direct_io,omitempty"`

	// Enable POSIX ACLs, implies xattr support
	ExposeACL *bool `json:"exposeAcl,omitempty" tf:"expose_acl,omitempty"`

	// Enable support for extended attributes
	ExposeXattr *bool `json:"exposeXattr,omitempty" tf:"expose_xattr,omitempty"`

	// Directory mapping identifier
	Mapping *string `json:"mapping,omitempty" tf:"mapping,omitempty"`
}

type VirtiofsParameters struct {

	// The caching mode
	// +kubebuilder:validation:Optional
	Cache *string `json:"cache,omitempty" tf:"cache,omitempty"`

	// Whether to allow direct io
	// +kubebuilder:validation:Optional
	DirectIo *bool `json:"directIo,omitempty" tf:"direct_io,omitempty"`

	// Enable POSIX ACLs, implies xattr support
	// +kubebuilder:validation:Optional
	ExposeACL *bool `json:"exposeAcl,omitempty" tf:"expose_acl,omitempty"`

	// Enable support for extended attributes
	// +kubebuilder:validation:Optional
	ExposeXattr *bool `json:"exposeXattr,omitempty" tf:"expose_xattr,omitempty"`

	// Directory mapping identifier
	// +kubebuilder:validation:Optional
	Mapping *string `json:"mapping" tf:"mapping,omitempty"`
}

type WatchdogInitParameters struct {

	// The watchdog action
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// Whether the watchdog is enabled
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// The watchdog model
	Model *string `json:"model,omitempty" tf:"model,omitempty"`
}

type WatchdogObservation struct {

	// The watchdog action
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// Whether the watchdog is enabled
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// The watchdog model
	Model *string `json:"model,omitempty" tf:"model,omitempty"`
}

type WatchdogParameters struct {

	// The watchdog action
	// +kubebuilder:validation:Optional
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// Whether the watchdog is enabled
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// The watchdog model
	// +kubebuilder:validation:Optional
	Model *string `json:"model,omitempty" tf:"model,omitempty"`
}

// EnvironmentVMSpec defines the desired state of EnvironmentVM
type EnvironmentVMSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     EnvironmentVMParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider EnvironmentVMInitParameters `json:"initProvider,omitempty"`
}

// EnvironmentVMStatus defines the observed state of EnvironmentVM.
type EnvironmentVMStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        EnvironmentVMObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// EnvironmentVM is the Schema for the EnvironmentVMs API. <no value>
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,proxmoxbpg}
type EnvironmentVM struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.nodeName) || (has(self.initProvider) && has(self.initProvider.nodeName))",message="spec.forProvider.nodeName is a required parameter"
	Spec   EnvironmentVMSpec   `json:"spec"`
	Status EnvironmentVMStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// EnvironmentVMList contains a list of EnvironmentVMs
type EnvironmentVMList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []EnvironmentVM `json:"items"`
}

// Repository type metadata.
var (
	EnvironmentVM_Kind             = "EnvironmentVM"
	EnvironmentVM_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: EnvironmentVM_Kind}.String()
	EnvironmentVM_KindAPIVersion   = EnvironmentVM_Kind + "." + CRDGroupVersion.String()
	EnvironmentVM_GroupVersionKind = CRDGroupVersion.WithKind(EnvironmentVM_Kind)
)

func init() {
	SchemeBuilder.Register(&EnvironmentVM{}, &EnvironmentVMList{})
}
